<script setup lang="ts">
import { Points } from "./utils";

/**
 * 分析
 *  1.线条绘制
 *      多个点的连接
 *      鼠标按下是起始点
 *      鼠标移动，产生过程点
 *      鼠标抬起，绘制结束
 *  2.矩形绘制
 *      需要的数据：起始点，宽高
 *      鼠标按下，获得起始点
 *      鼠标移动，产生过程点
 *      通过两点，可以计算宽高
 *      矩形在绘制过程中，没有抬起鼠标，则还处于选择阶段，矩形还没有确定，有一个拖拽的视觉效果。实际上是一个不断绘制的过程。此时存在一个问题
 *        由于矩形会与其他图像产生覆盖，如果删除之前绘制的矩形，也会将之前图像覆盖的部分也删除
 *        为了提高性能，考虑使用2个画布。第一个画布绘制当前的这个图像，抬起鼠标后，图像确定再将其绘制到第二个画布上
 *  3.圆型
 *      需要的数据：圆心点、半径
 *      鼠标按下获得起始点
 *      鼠标移动，产生过程点
 *      起始点与过程点，计算半径和圆心点
 *      可能是正圆、也有可能是椭圆
 *      原的拖拽绘制与矩形相同
 *  4.填充
 *      不是对某个图形进行填充，而是对一块合围区域填充
 *      合围区域可能是有多个图像部分合围而成
 *      难点：如果确定这个合围区域（可以通过像素操作来实现）
 *  5. 橡皮檫
 *    本质还是画线条
 *    只不过与原图形的合成关系发生了变化
 *  6.
 *
 * 结论
 *   需要2个画布，一个体现绘制过程，一个用来展示绘制结果
 *   许愿哦图形对象，包括多种类型（线条、矩形、圆状、橡皮檫）
 */

const pointsRef = ref<Points>();

onMounted(() => {
  setTimeout(() => {
    const boxDom = document.querySelector(".box")! as HTMLElement;
    pointsRef.value = new Points(boxDom);
  }, 1000);
});

onBeforeUnmount(() => {
  pointsRef.value?.destroy();
});
</script>

<template>
  <div class="box"></div>
</template>

<style scoped></style>
